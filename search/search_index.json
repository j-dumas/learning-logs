{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to my collection of learning notes. I document my learning experience with various subjects, including my Master's Degree in ICS Security. Notes are written in Obsidian and selected to be published to Github Pages.</p>"},{"location":"#topics","title":"Topics","text":"<ul> <li>Information Security</li> <li>OS dev</li> <li>Embedded</li> <li>etc.</li> </ul>"},{"location":"#table-of-content","title":"Table of Content","text":""},{"location":"#projects","title":"Projects","text":"<ul> <li>Overview</li> <li>Podman Development Containers</li> </ul>"},{"location":"#courses","title":"Courses","text":"<ul> <li>C++ Build Process</li> </ul>"},{"location":"#readings","title":"Readings","text":"<ul> <li>Data Structures and Algorithms in C++</li> </ul>"},{"location":"#ctf","title":"CTF","text":""},{"location":"courses/cpp-build-process/","title":"C++ Build Process","text":"<p>From studyplan.dev</p> <p>This course is about how to use CMake to build C++ projects.</p> <p>We learned C++ in my degree, but never how to use CMake (maybe because my already credited courses from my previous DEC talked about it). I actually used it a bit in an internship to build a program running on multiple ESP32s with the ESP-IDF.</p> <p>I want to use it more in my next projects, be it in C or C++.</p>"},{"location":"courses/cpp-build-process/#sections","title":"Sections","text":""},{"location":"courses/cpp-build-process/#chapter-1","title":"Chapter 1","text":"<p>This chapter was mostly revision of what I already knew about compilers, with added information about compiler flags and the <code>ar</code> program for static libraries.</p> <p>It presents mostly each step of the compilation process (preprocessing, compiling, assembling, linking) and shows the different tools needed to do it by hand in the CLI before using CMake.</p>"},{"location":"courses/cpp-build-process/#-learned","title":"\ud83d\udccc Learned","text":"<ul> <li>Compiler flags for different steps of the compilation process</li> <li><code>ar</code> for archiving static libraries</li> <li>Position-Independent Code for dynamic libraries</li> <li>A simple Hello World program with <code>&lt;iostream&gt;</code> is 25k lines after preprocessing since it includes the whole iostream headers</li> </ul>"},{"location":"projects/podman-devcontainers/","title":"Podman Development Containers","text":"<p>Part of my dotfiles</p>"},{"location":"projects/podman-devcontainers/#summary","title":"Summary","text":"<p>I am adding a base Containerfile (Dockerfile) and a script to create Podman containers with images based on the base Containerfile to create development environments as containers. It came from wanting DevContainers without having to use VSCode (I know there are Neovim features, but still...).  I also looked at Distrobox, but I wanted more isolation for my home directory.</p>"},{"location":"projects/podman-devcontainers/#goal","title":"Goal","text":"<p>The goal of this project is to learn containerization and Podman, but mostly have a working and clean development environment for developing other projects without installing dependencies on my host system. I also wanted the possibility to have a base environment with my tools that I can add to for specific projects.</p>"},{"location":"projects/podman-devcontainers/#progress","title":"Progress","text":"<p>Here is the base Containerfile based on Arch Linux. I mostly install needed packages and create a user and a nice prompt. <pre><code>FROM archlinux:latest \nLABEL Description=\"Base development env\" \n\n# Installed needed development packages\nRUN pacman -Syu --noconfirm \\\n    base-devel \\\n    zsh \\\n    neovim \\\n    git \\\n    wget \n\nRUN pacman -Scc --noconfirm \n\n# Create non root user\nRUN useradd -m -s /usr/bin/zsh jdumas\nUSER jdumas\n\n# Initialize folders so they are not root owned on mount\nRUN mkdir /home/jdumas/.local &amp;&amp; mkdir /home/jdumas/.config\n\nENV HOME /home/jdumas\nENV PROMPT=\"%F{#a6e3a1}%n%f@%F{#89b4fa}%m%f:%F{#fab387}%~%f $ \"\n\nWORKDIR /home/jdumas/src\nCMD [\"/usr/bin/zsh\"]\n</code></pre></p> <p>Then, to create the container, I use the following script. It takes a flag (<code>-n</code>) to tell the script that we want to use the base image for the container (otherwise we need a new Containerfile for dependencies additions). It also takes a name for the container and the optional path to the project folder to mount it in the container to work on it. It basically parses arguments, creates images and creates a container with the appropriate volumes. <pre><code>#!/usr/bin/env bash\n\nBASE_IMG_NAME=\"devenv\"\nNO_NEW_IMG=false\n\n# Order of parameters :\n#   1. flag to use base img for the container\n#   2. name\n#   3. path to project (to share folder)\nusage() {\n    echo \"Usage: devenv [-n for no new image] &lt;container name&gt; [project path]\"\n}\n\n# Parse argument -n\nwhile getopts \"n\" opt; do \n    case ${opt} in \n        n) NO_NEW_IMG=true;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nNAME=$1\nPROJECT_PATH=$(realpath ${2:-$(pwd)})\n\nif [ -z $NAME ]; then\n    usage\n    exit 1\nfi\n\n# Create base image\nif ! podman image exists $BASE_IMG_NAME; then\n    podman build -f ~/BaseEnvContainerfile -t devenv .\nfi\n\n# Create other image if needed\nif [ $NO_NEW_IMG = true ]; then\n    IMG_NAME=$BASE_IMG_NAME\nelse \n    IMG_NAME=$NAME\n    podman build -f $PROJECT_PATH/EnvContainerfile -t $NAME $PROJECT_PATH\nfi\n\n# Create container with correct image, volumes and namespace\npodman create -t --name $NAME \\\n    --userns=keep-id \\\n    -v $HOME/.config/nvim:/home/jdumas/.config/nvim \\\n    -v $HOME/.local/dev/nvim-container-share:/home/jdumas/.local/share/nvim \\\n    -v $PROJECT_PATH:/home/jdumas/src \\\n    -h $NAME $IMG_NAME\n</code></pre></p> <p>For example, a Containerfile using the base would be called <code>EnvContainerfile</code> and would look like : <pre><code>FROM devenv\nLABEL Description=\"Game Theory env\"\n\nUSER root\n\nRUN pacman -Syu --noconfirm \\\n    graphviz\n\nRUN pacman -Scc --noconfirm \n\nUSER jdumas\n</code></pre></p> <p>This is the Containerfile for a game theory project using Graphviz to display trees. I would create the container by calling the script like this from the project directory : <pre><code>devenv tree_viewer .\n</code></pre></p> <p>I can then start it with <pre><code>podman start -ia tree_viewer\n</code></pre></p>"},{"location":"projects/podman-devcontainers/#-learned","title":"\ud83d\udccc Learned","text":"<ul> <li>How to create a new user and how to install packages in a Containerfile</li> <li>How to build and check for image existence</li> <li>How to bind mount volumes and set correct owner</li> <li>How to use default parameters in a bash script and how to use <code>getopts</code></li> <li>Learned a lot about Podman and isolation</li> </ul>"},{"location":"projects/podman-devcontainers/#challenges","title":"\ud83c\udfafChallenges","text":"<ul> <li>How to take a path or use a default path?    Use bash variable expansion with <code>realpath</code> and <code>pwd</code></li> <li>How to build a base image if it does not already exist?   <code>podman image exists</code></li> <li>What if I want to use de base image for the container and not another one built on top?   New flag parameter with <code>getopts</code></li> <li>How do I make Neovim's plugins installation faster for each container, instead of reinstalling each time, without compromising my host installation?   Mount a custom folder for storing the containers' data separate from the host so installation is done only once</li> <li>Mounted volumes are own by root by default, which mean Neovim cannot install its plugins.   Needed to match the host UID/GID inside the container using <code>--userns=keep-id</code> and by creating needed parent folders in the image creation</li> </ul>"},{"location":"projects/projects-overview/","title":"Overview","text":"<ul> <li>[[efgtv-overview|Extensive Form Game Tree Viewer]]</li> <li>Podman Development Containers</li> </ul>"},{"location":"readings/dsa-cpp/dsacpp-overview/","title":"Overview","text":"<p>Data Structures and Algorithms in C++ by Mark Allen Weiss</p> <p>During my Bachelor degree, I have read this book as additional lectures for a course on the same subject. Since then, I have nearly forgotten all of the important material ...</p> <p>I am now reading back parts of this book to relearn the basics of Data Structures to then help me with Leetcode (to use included C++ data structures instead of redoing them, but still understanding them).</p>"},{"location":"readings/dsa-cpp/dsacpp-overview/#sections","title":"Sections","text":""}]}