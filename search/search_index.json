{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Welcome to my collection of learning notes. I document my learning experience with various subjects, including my Master's Degree in ICS Security. Notes are written in Obsidian and selected to be published to Github Pages.</p> <p>Disclaimer: these notes were written by hand. No LLM was used to write, even though emojis are used. They are only for fast lookup of the pages and structure.</p>"},{"location":"#topics","title":"Topics","text":"<ul> <li>Information Security</li> <li>OS dev</li> <li>Embedded</li> <li>etc.</li> </ul>"},{"location":"#table-of-content","title":"Table of Content","text":""},{"location":"#projects","title":"Projects","text":"<ul> <li>Overview</li> <li>Podman Development Containers</li> </ul>"},{"location":"#courses","title":"Courses","text":"<ul> <li>Managing C++ Projects Using CMake</li> </ul>"},{"location":"#readings","title":"Readings","text":"<ul> <li>Data Structures and Algorithms in C++</li> </ul>"},{"location":"#ctf","title":"CTF","text":""},{"location":"courses/managing-cpp-cmake/","title":"Managing C++ Projects Using CMake","text":"<p>From studyplan.dev</p> <p>This course is about how to use CMake to build C++ projects.</p> <p>We learned C++ in my degree, but never how to use CMake (maybe because my already credited courses from my previous DEC talked about it). I actually used it a bit in an internship to build a program running on multiple ESP32s with the ESP-IDF.</p> <p>I want to use it more in my next projects, be it in C or C++.</p>"},{"location":"courses/managing-cpp-cmake/#sections","title":"Sections","text":""},{"location":"courses/managing-cpp-cmake/#chapter-1---the-c-build-process","title":"Chapter 1 - The C++ Build Process","text":"<p>This chapter was mostly revision of what I already knew about compilers, with added information about compiler flags and the <code>ar</code> program for static libraries.</p> <p>It presents mostly each step of the compilation process (preprocessing, compiling, assembling, linking) and shows the different tools needed to do it by hand in the CLI before using CMake.</p>"},{"location":"courses/managing-cpp-cmake/#-learned","title":"\ud83d\udccc Learned","text":"<ul> <li>Compiler flags for different steps of the compilation process</li> <li><code>ar</code> for archiving static libraries</li> <li>Position-Independent Code for dynamic libraries</li> <li>A simple Hello World program with <code>&lt;iostream&gt;</code> is 25k lines after preprocessing since it includes the whole iostream headers</li> </ul>"},{"location":"courses/managing-cpp-cmake/#chapter-2---project-structure-and-dependency-management","title":"Chapter 2 - Project Structure and Dependency Management","text":"<p>This chapter presents the organization of a C++ project as well as build systems and their limitations for complex projects. It talked about versioning, project layout, API vs ABI, etc.</p>"},{"location":"courses/managing-cpp-cmake/#-learned_1","title":"\ud83d\udccc Learned","text":"<ul> <li>Typical C++ projet layout consisting of <code>src</code> folder for the source code and private headers, <code>include</code> folder for the public headers and<code>libs</code> folder for external libraries</li> <li>Two ways of separating multiple parts of a project like <code>core</code> and <code>graphics</code> by either having folder for each part under <code>src</code> and <code>include</code> or having <code>src</code> and <code>include</code> in each folder of each part</li> <li>Compiler flags for linking libraries (<code>-I</code>, <code>-L</code>, <code>-l</code>)</li> <li>Semantic versioning</li> <li>Platform differences such has two file system for a <code>dll</code> on Windows (<code>.lib</code> and <code>.dll</code>) vs <code>.so</code> on Linux and macOS</li> <li>Limitations of Makefiles and IDE Project files such as vendor lock-in, dependency on GUI or the monolithic unreadable single Makefile and duplication when splitting it</li> </ul>"},{"location":"courses/managing-cpp-cmake/#chapter-3---introducing-cmake","title":"Chapter 3 - Introducing CMake","text":"<p>As said before, I had already used CMake in an intership before and was already a familiar with the basics. I therefore did not learn much about the basic commands like <code>add_executable</code>, <code>add_library</code>, <code>target_link_libraries</code>, etc.</p> <p>I did learn more reasons as to why use CMake and little tips about structure and versions.</p>"},{"location":"courses/managing-cpp-cmake/#-learned_2","title":"\ud83d\udccc Learned","text":"<ul> <li>Why CMake? portability, reproducibility and consistency, and maintainability and scalability</li> <li>CMake alternatives such as Bazel or Meson, but CMake remains the most widely adopted</li> <li>Tips on choosing a version of CMake: <ul> <li>Old enough to be compatible with most tools</li> <li>New enough to have modern features and still be supported</li> </ul> </li> <li>Tips about choosing the <code>target_</code> version of a command: granularity, clarity and transitivity</li> </ul> <p><code>compile_commands</code></p> <p>To generate a <code>compile_commands.json</code> file to be used by the <code>clangd</code> LSP for ease of programming (auto-completion, linting, etc.), add  <pre><code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n</code></pre></p>"},{"location":"projects/podman-devcontainers/","title":"Podman Development Containers","text":"<p>Part of my dotfiles</p>"},{"location":"projects/podman-devcontainers/#summary","title":"Summary","text":"<p>I am adding a base Containerfile (Dockerfile) and a script to create Podman containers with images based on the base Containerfile to create development environments as containers. It came from wanting DevContainers without having to use VSCode (I know there are Neovim features, but still...).  I also looked at Distrobox, but I wanted more isolation for my home directory.</p>"},{"location":"projects/podman-devcontainers/#goal","title":"Goal","text":"<p>The goal of this project is to learn containerization and Podman, but mostly have a working and clean development environment for developing other projects without installing dependencies on my host system. I also wanted the possibility to have a base environment with my tools that I can add to for specific projects.</p>"},{"location":"projects/podman-devcontainers/#progress","title":"Progress","text":"<p>Here is the base Containerfile based on Arch Linux. I mostly install needed packages and create a user and a nice prompt. <pre><code>FROM archlinux:latest \nLABEL Description=\"Base development env\" \n\n# Installed needed development packages\nRUN pacman -Syu --noconfirm \\\n    base-devel \\\n    zsh \\\n    neovim \\\n    git \\\n    wget \n\nRUN pacman -Scc --noconfirm \n\n# Create non root user\nRUN useradd -m -s /usr/bin/zsh jdumas\nUSER jdumas\n\n# Initialize folders so they are not root owned on mount\nRUN mkdir /home/jdumas/.local &amp;&amp; mkdir /home/jdumas/.config\n\nENV HOME /home/jdumas\nENV PROMPT=\"%F{#a6e3a1}%n%f@%F{#89b4fa}%m%f:%F{#fab387}%~%f $ \"\n\nWORKDIR /home/jdumas/src\nCMD [\"/usr/bin/zsh\"]\n</code></pre></p> <p>Then, to create the container, I use the following script. It takes a flag (<code>-n</code>) to tell the script that we want to use the base image for the container (otherwise we need a new Containerfile for dependencies additions). It also takes a name for the container and the optional path to the project folder to mount it in the container to work on it. It basically parses arguments, creates images and creates a container with the appropriate volumes. <pre><code>#!/usr/bin/env bash\n\nBASE_IMG_NAME=\"devenv\"\nNO_NEW_IMG=false\n\n# Order of parameters :\n#   1. flag to use base img for the container\n#   2. name\n#   3. path to project (to share folder)\nusage() {\n    echo \"Usage: devenv [-n for no new image] &lt;container name&gt; [project path]\"\n}\n\n# Parse argument -n\nwhile getopts \"n\" opt; do \n    case ${opt} in \n        n) NO_NEW_IMG=true;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nNAME=$1\nPROJECT_PATH=$(realpath ${2:-$(pwd)})\n\nif [ -z $NAME ]; then\n    usage\n    exit 1\nfi\n\n# Create base image\nif ! podman image exists $BASE_IMG_NAME; then\n    podman build -f ~/BaseEnvContainerfile -t devenv .\nfi\n\n# Create other image if needed\nif [ $NO_NEW_IMG = true ]; then\n    IMG_NAME=$BASE_IMG_NAME\nelse \n    IMG_NAME=$NAME\n    podman build -f $PROJECT_PATH/EnvContainerfile -t $NAME $PROJECT_PATH\nfi\n\n# Create container with correct image, volumes and namespace\npodman create -t --name $NAME \\\n    --userns=keep-id \\\n    -v $HOME/.config/nvim:/home/jdumas/.config/nvim \\\n    -v $HOME/.local/dev/nvim-container-share:/home/jdumas/.local/share/nvim \\\n    -v $PROJECT_PATH:/home/jdumas/src \\\n    -h $NAME $IMG_NAME\n</code></pre></p> <p>For example, a Containerfile using the base would be called <code>EnvContainerfile</code> and would look like : <pre><code>FROM devenv\nLABEL Description=\"Game Theory env\"\n\nUSER root\n\nRUN pacman -Syu --noconfirm \\\n    graphviz\n\nRUN pacman -Scc --noconfirm \n\nUSER jdumas\n</code></pre></p> <p>This is the Containerfile for a game theory project using Graphviz to display trees. I would create the container by calling the script like this from the project directory : <pre><code>devenv tree_viewer .\n</code></pre></p> <p>I can then start it with <pre><code>podman start -ia tree_viewer\n</code></pre></p>"},{"location":"projects/podman-devcontainers/#-learned","title":"\ud83d\udccc Learned","text":"<ul> <li>How to create a new user and how to install packages in a Containerfile</li> <li>How to build and check for image existence</li> <li>How to bind mount volumes and set correct owner</li> <li>How to use default parameters in a bash script and how to use <code>getopts</code></li> <li>Learned a lot about Podman and isolation</li> </ul>"},{"location":"projects/podman-devcontainers/#challenges","title":"\ud83c\udfafChallenges","text":"<ul> <li>How to take a path or use a default path?    Use bash variable expansion with <code>realpath</code> and <code>pwd</code></li> <li>How to build a base image if it does not already exist? <code>podman image exists</code></li> <li>What if I want to use de base image for the container and not another one built on top?   New flag parameter with <code>getopts</code></li> <li>How do I make Neovim's plugins installation faster for each container, instead of reinstalling each time, without compromising my host installation?   Mount a custom folder for storing the containers' data separate from the host so installation is done only once</li> <li>Mounted volumes are own by root by default, which mean Neovim cannot install its plugins.   Needed to match the host UID/GID inside the container using <code>--userns=keep-id</code> and by creating needed parent folders in the image creation</li> </ul>"},{"location":"projects/projects-overview/","title":"Overview","text":"<ul> <li>Podman Development Containers</li> </ul>"},{"location":"readings/dsa-cpp/dsacpp-overview/","title":"Overview","text":"<p>Data Structures and Algorithms in C++ by Mark Allen Weiss</p> <p>During my Bachelor degree, I have read this book as additional lectures for a course on the same subject. Since then, I have nearly forgotten all of the important material ...</p> <p>I am now reading back parts of this book to relearn the basics of Data Structures to then help me with Leetcode (to use included C++ data structures instead of redoing them, but still understanding them).</p>"},{"location":"readings/dsa-cpp/dsacpp-overview/#sections","title":"Sections","text":""}]}